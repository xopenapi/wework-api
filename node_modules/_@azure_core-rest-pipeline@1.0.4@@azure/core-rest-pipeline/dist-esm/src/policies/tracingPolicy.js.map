{"version":3,"file":"tracingPolicy.js","sourceRoot":"","sources":["../../../src/policies/tracingPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  getTraceParentHeader,\n  OperationTracingOptions,\n  createSpanFunction\n} from \"@azure/core-tracing\";\nimport { SpanKind } from \"@azure/core-tracing\";\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { URL } from \"../util/url\";\nimport { getUserAgentValue } from \"../util/userAgent\";\n\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      // create a new span\n      const tracingOptions: OperationTracingOptions = {\n        ...request.tracingOptions,\n        spanOptions: {\n          ...request.tracingOptions.spanOptions,\n          kind: SpanKind.CLIENT\n        }\n      };\n\n      const url = new URL(request.url);\n      const path = url.pathname || \"/\";\n\n      const { span } = createSpan(path, { tracingOptions });\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n\n      if (userAgent) {\n        span.setAttribute(\"http.user_agent\", userAgent);\n      }\n\n      try {\n        // set headers\n        const spanContext = span.context();\n        const traceParentHeader = getTraceParentHeader(spanContext);\n        if (traceParentHeader) {\n          request.headers.set(\"traceparent\", traceParentHeader);\n          const traceState = spanContext.traceState && spanContext.traceState.serialize();\n          // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n          if (traceState) {\n            request.headers.set(\"tracestate\", traceState);\n          }\n        }\n\n        const response = await next(request);\n        span.setAttribute(\"http.status_code\", response.status);\n        const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n        if (serviceRequestId) {\n          span.setAttribute(\"serviceRequestId\", serviceRequestId);\n        }\n        span.end();\n        return response;\n      } catch (err) {\n        span.end();\n        throw err;\n      }\n    }\n  };\n}\n"]}