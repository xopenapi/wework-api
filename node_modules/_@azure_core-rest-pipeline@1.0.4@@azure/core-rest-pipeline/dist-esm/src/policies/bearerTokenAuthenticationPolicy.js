// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { ExpiringAccessTokenCache } from "../accessTokenCache";
/**
 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
 */
export const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
/**
 * A policy that can request a token from a TokenCredential implementation and
 * then apply it to the Authorization header of a request as a Bearer token.
 */
export function bearerTokenAuthenticationPolicy(options) {
    const { credential, scopes } = options;
    const tokenCache = new ExpiringAccessTokenCache();
    function getToken(tokenOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let accessToken = tokenCache.getCachedToken();
            if (accessToken === undefined) {
                accessToken = (yield credential.getToken(scopes, tokenOptions)) || undefined;
                tokenCache.setCachedToken(accessToken);
            }
            return accessToken ? accessToken.token : undefined;
        });
    }
    return {
        name: bearerTokenAuthenticationPolicyName,
        sendRequest(request, next) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield getToken({
                    abortSignal: request.abortSignal,
                    tracingOptions: request.tracingOptions
                });
                request.headers.set("Authorization", `Bearer ${token}`);
                return next(request);
            });
        }
    };
}
//# sourceMappingURL=bearerTokenAuthenticationPolicy.js.map