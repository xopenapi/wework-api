{"version":3,"file":"bearerTokenAuthenticationPolicy.js","sourceRoot":"","sources":["../../../src/policies/bearerTokenAuthenticationPolicy.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAKlC,OAAO,EAAoB,wBAAwB,EAAE,MAAM,qBAAqB,CAAC;AAEjF;;GAEG;AACH,MAAM,CAAC,MAAM,mCAAmC,GAAG,iCAAiC,CAAC;AAgBrF;;;GAGG;AACH,MAAM,UAAU,+BAA+B,CAC7C,OAA+C;IAE/C,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;IACvC,MAAM,UAAU,GAAqB,IAAI,wBAAwB,EAAE,CAAC;IACpE,SAAe,QAAQ,CAAC,YAA6B;;YACnD,IAAI,WAAW,GAAG,UAAU,CAAC,cAAc,EAAE,CAAC;YAC9C,IAAI,WAAW,KAAK,SAAS,EAAE;gBAC7B,WAAW,GAAG,CAAC,MAAM,UAAU,CAAC,QAAQ,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC,IAAI,SAAS,CAAC;gBAC7E,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;aACxC;YAED,OAAO,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;QACrD,CAAC;KAAA;IACD,OAAO;QACL,IAAI,EAAE,mCAAmC;QACnC,WAAW,CAAC,OAAwB,EAAE,IAAiB;;gBAC3D,MAAM,KAAK,GAAG,MAAM,QAAQ,CAAC;oBAC3B,WAAW,EAAE,OAAO,CAAC,WAAW;oBAChC,cAAc,EAAE,OAAO,CAAC,cAAc;iBACvC,CAAC,CAAC;gBACH,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,UAAU,KAAK,EAAE,CAAC,CAAC;gBACxD,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC;YACvB,CAAC;SAAA;KACF,CAAC;AACJ,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { TokenCredential, GetTokenOptions } from \"@azure/core-auth\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"../accessTokenCache\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions\n): PipelinePolicy {\n  const { credential, scopes } = options;\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  async function getToken(tokenOptions: GetTokenOptions): Promise<string | undefined> {\n    let accessToken = tokenCache.getCachedToken();\n    if (accessToken === undefined) {\n      accessToken = (await credential.getToken(scopes, tokenOptions)) || undefined;\n      tokenCache.setCachedToken(accessToken);\n    }\n\n    return accessToken ? accessToken.token : undefined;\n  }\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const token = await getToken({\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions\n      });\n      request.headers.set(\"Authorization\", `Bearer ${token}`);\n      return next(request);\n    }\n  };\n}\n"]}