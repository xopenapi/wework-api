'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var url = require('url');

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
 */
const keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
function keyCredentialAuthenticationPolicy(credential, apiKeyHeaderName) {
    return {
        name: keyCredentialAuthenticationPolicyName,
        sendRequest(request, next) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                request.headers.set(apiKeyHeaderName, credential.key);
                return next(request);
            });
        },
    };
}

// Copyright (c) Microsoft Corporation.
let cachedHttpClient;
/**
 * Creates a default rest pipeline to re-use accross Rest Level Clients
 */
function createDefaultPipeline(baseUrl, credential, options = {}) {
    var _a, _b, _c, _d;
    const pipeline = coreRestPipeline.createPipelineFromOptions(options);
    pipeline.removePolicy({ name: "exponentialRetryPolicy" });
    if (credential) {
        if (coreAuth.isTokenCredential(credential)) {
            const tokenPolicy = coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential,
                scopes: (_b = (_a = options.credentials) === null || _a === void 0 ? void 0 : _a.scopes) !== null && _b !== void 0 ? _b : `${baseUrl}/.default`,
            });
            pipeline.addPolicy(tokenPolicy);
        }
        else if (isKeyCredential(credential)) {
            if (!((_c = options.credentials) === null || _c === void 0 ? void 0 : _c.apiKeyHeaderName)) {
                throw new Error(`Missing API Key Header Name`);
            }
            const keyPolicy = keyCredentialAuthenticationPolicy(credential, (_d = options.credentials) === null || _d === void 0 ? void 0 : _d.apiKeyHeaderName);
            pipeline.addPolicy(keyPolicy);
        }
    }
    return pipeline;
}
function isKeyCredential(credential) {
    return credential.key !== undefined;
}
function getCachedDefaultHttpsClient() {
    if (!cachedHttpClient) {
        cachedHttpClient = coreRestPipeline.createDefaultHttpClient();
    }
    return cachedHttpClient;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 * @internal
 */
function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
        return false;
    }
    for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
            return false;
        }
    }
    return true;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 * @internal
 */
function objectHasProperty(thing, property) {
    return typeof thing === "object" && property in thing;
}

// Copyright (c) Microsoft Corporation.
/**
 * Tests an object to determine whether it implements CertificateCredential.
 *
 * @param credential - The assumed CertificateCredential to be tested.
 */
function isCertificateCredential(credential) {
    return (isObjectWithProperties(credential, ["certKey", "cert"]) &&
        typeof credential.cert === "string" &&
        typeof credential.certKey === "string");
}

// Copyright (c) Microsoft Corporation.
/**
 * Helper function to send request used by the client
 * @param method - method to use to send the request
 * @param url - url to send the request to
 * @param pipeline - pipeline with the policies to run when sending the request
 * @param options - request options
 * @returns returns and HttpResponse
 */
function sendRequest(method, url, pipeline, options = {}) {
    var _a, _b;
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const httpClient = getCachedDefaultHttpsClient();
        const body = options.body !== undefined ? JSON.stringify(options.body) : undefined;
        const headers = coreRestPipeline.createHttpHeaders(Object.assign(Object.assign({ accept: (_a = options.accept) !== null && _a !== void 0 ? _a : "application/json" }, (body !== undefined && {
            "content-type": (_b = options.contentType) !== null && _b !== void 0 ? _b : getContentType(options.body),
        })), (options.headers ? options.headers : {})));
        const request = coreRestPipeline.createPipelineRequest({
            url,
            method,
            body,
            headers,
            allowInsecureConnection: options.allowInsecureConnection,
        });
        const result = yield pipeline.sendRequest(httpClient, request);
        const rawHeaders = result.headers.toJSON();
        let parsedBody = undefined;
        try {
            parsedBody = result.bodyAsText ? JSON.parse(result.bodyAsText) : undefined;
        }
        catch (_c) {
            parsedBody = undefined;
        }
        return {
            request,
            headers: rawHeaders,
            status: `${result.status}`,
            body: parsedBody,
        };
    });
}
/**
 * Function to determine the content-type of a body
 * this is used if an explicit content-type is not provided
 * @param body - body in the request
 * @returns returns the content-type
 */
function getContentType(body) {
    if (ArrayBuffer.isView(body)) {
        return "application/octet-stream";
    }
    // By default return json
    return "application/json; charset=UTF-8";
}

// Copyright (c) Microsoft Corporation.
/**
 * Builds the request url, filling in query and path parameters
 * @param baseUrl - base url which can be a template url
 * @param routePath - path to append to the baseUrl
 * @param pathParameters - values of the path parameters
 * @param options - request parameters including query parameters
 * @returns a full url with path and query parameters
 */
function buildRequestUrl(baseUrl, routePath, pathParameters, options = {}) {
    let path = routePath;
    if (path.startsWith("https://") || path.startsWith("http://")) {
        return path;
    }
    for (const pathParam of pathParameters) {
        path = path.replace(/{([^/]+)}/, pathParam);
    }
    const url$1 = new url.URL(`${baseUrl}/${path}`);
    if (options.queryParameters) {
        const queryParams = options.queryParameters;
        for (const key of Object.keys(queryParams)) {
            const param = queryParams[key];
            if (!param.toString || typeof param.toString !== "function") {
                throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
            }
            const value = param.toISOString !== undefined ? param.toISOString() : param.toString();
            url$1.searchParams.append(key, value);
        }
    }
    return (url$1
        .toString()
        // Remove double forward slashes
        .replace(/([^:]\/)\/+/g, "$1"));
}

// Copyright (c) Microsoft Corporation.
function getClient(baseUrl, credentialsOrPipelineOptions, clientOptions = {}) {
    let credentials;
    if (credentialsOrPipelineOptions) {
        if (isCredential(credentialsOrPipelineOptions)) {
            credentials = credentialsOrPipelineOptions;
        }
        else {
            clientOptions = credentialsOrPipelineOptions !== null && credentialsOrPipelineOptions !== void 0 ? credentialsOrPipelineOptions : {};
        }
    }
    const pipeline = createDefaultPipeline(baseUrl, credentials, clientOptions);
    const client = (path, ...args) => {
        return {
            get: (options = {}) => {
                return buildSendRequest("GET", clientOptions, baseUrl, path, pipeline, options, args);
            },
            post: (options = {}) => {
                return buildSendRequest("POST", clientOptions, baseUrl, path, pipeline, options, args);
            },
            put: (options = {}) => {
                return buildSendRequest("PUT", clientOptions, baseUrl, path, pipeline, options, args);
            },
            patch: (options = {}) => {
                return buildSendRequest("PATCH", clientOptions, baseUrl, path, pipeline, options, args);
            },
            delete: (options = {}) => {
                return buildSendRequest("DELETE", clientOptions, baseUrl, path, pipeline, options, args);
            },
            head: (options = {}) => {
                return buildSendRequest("HEAD", clientOptions, baseUrl, path, pipeline, options, args);
            },
            options: (options = {}) => {
                return buildSendRequest("OPTIONS", clientOptions, baseUrl, path, pipeline, options, args);
            },
            trace: (options = {}) => {
                return buildSendRequest("TRACE", clientOptions, baseUrl, path, pipeline, options, args);
            },
        };
    };
    return {
        path: client,
        pathUnchecked: client,
        pipeline,
    };
}
function buildSendRequest(method, clientOptions, baseUrl, path, pipeline, requestOptions = {}, args = []) {
    var _a;
    // If the client has an api-version and the request doesn't specify one, inject the one in the client options
    if (!((_a = requestOptions.queryParameters) === null || _a === void 0 ? void 0 : _a["api-version"]) && clientOptions.apiVersion) {
        if (!requestOptions.queryParameters) {
            requestOptions.queryParameters = {};
        }
        requestOptions.queryParameters["api-version"] = clientOptions.apiVersion;
    }
    const url = buildRequestUrl(baseUrl, path, args, requestOptions);
    return sendRequest(method, url, pipeline, requestOptions);
}
function isCredential(param) {
    if (param.key !== undefined ||
        coreAuth.isTokenCredential(param) ||
        isCertificateCredential(param)) {
        return true;
    }
    return false;
}

exports.createDefaultPipeline = createDefaultPipeline;
exports.getClient = getClient;
exports.isCertificateCredential = isCertificateCredential;
//# sourceMappingURL=index.js.map
