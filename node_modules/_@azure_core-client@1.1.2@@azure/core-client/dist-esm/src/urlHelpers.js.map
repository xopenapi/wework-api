{"version":3,"file":"urlHelpers.js","sourceRoot":"","sources":["../../src/urlHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { URL } from \"./url\";\nimport { OperationSpec, OperationArguments, QueryCollectionFormat } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n\nconst CollectionFormatToDelimiterMap: { [key in QueryCollectionFormat]: string } = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\"\n};\n\nexport function getRequestUrl(\n  baseUri: string,\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): string {\n  const urlReplacements = calculateUrlReplacements(\n    operationSpec,\n    operationArguments,\n    fallbackObject\n  );\n\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    const path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n\n  const queryParams = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n  requestUrl = appendQueryParams(requestUrl, queryParams);\n\n  return requestUrl;\n}\n\nfunction replaceAll(input: string, replacements: Map<string, string>): string {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\n\nfunction calculateUrlReplacements(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): Map<string, string> {\n  const result = new Map<string, string>();\n  if (operationSpec.urlParameters?.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue: string = getOperationArgumentValueFromParameter(\n        operationArguments,\n        urlParameter,\n        fallbackObject\n      );\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(\n        urlParameter.mapper,\n        urlParameterValue,\n        parameterPathString\n      );\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(\n        `{${urlParameter.mapper.serializedName || parameterPathString}}`,\n        urlParameterValue\n      );\n    }\n  }\n  return result;\n}\n\nfunction isAbsoluteUrl(url: string): boolean {\n  return url.includes(\"://\");\n}\n\nfunction appendPath(url: string, pathToAppend?: string): string {\n  if (!pathToAppend) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n\n  parsedUrl.pathname = newPath;\n\n  return parsedUrl.toString();\n}\n\nfunction calculateQueryParameters(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): Map<string, string | string[]> {\n  const result = new Map<string, string | string[]>();\n  if (operationSpec.queryParameters?.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      let queryParameterValue: string | string[] = getOperationArgumentValueFromParameter(\n        operationArguments,\n        queryParameter,\n        fallbackObject\n      );\n      if (\n        (queryParameterValue !== undefined && queryParameterValue !== null) ||\n        queryParameter.mapper.required\n      ) {\n        queryParameterValue = operationSpec.serializer.serialize(\n          queryParameter.mapper,\n          queryParameterValue,\n          getPathStringFromParameter(queryParameter)\n        );\n\n        const delimiter = queryParameter.collectionFormat\n          ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n          : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map((item) => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map((item: string) => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n\n        result.set(\n          queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n          queryParameterValue\n        );\n      }\n    }\n  }\n  return result;\n}\n\nfunction simpleParseQueryParams(queryString: string): Array<[string, string]> {\n  if (!queryString || queryString[0] !== \"?\") {\n    return [];\n  }\n\n  // remove the leading ?\n  queryString = queryString.slice(1);\n\n  const pairs = queryString.split(\"&\");\n\n  return pairs.map((pair) => {\n    const [name, value] = pair.split(\"=\", 2);\n    return [name, value];\n  });\n}\n\nfunction appendQueryParams(url: string, queryParams: Map<string, string | string[]>): string {\n  if (queryParams.size === 0) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const existingParams = simpleParseQueryParams(parsedUrl.search);\n  const combinedParams = new Map<string, string | string[]>(existingParams);\n\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      existingValue.push(...value);\n    } else if (existingValue) {\n      combinedParams.set(name, [existingValue, ...value]);\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n\n  const searchPieces: string[] = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    }\n  }\n\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}\n"]}