"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.startSession = exports.Session = void 0;
const codegen_1 = require("@azure-tools/codegen");
const types_1 = require("./types");
const js_yaml_1 = require("js-yaml");
const safeEval = codegen_1.createSandbox();
async function getModel(service, yamlSchema = js_yaml_1.DEFAULT_SCHEMA, artifactType) {
    const files = await service.ListInputs(artifactType);
    const filename = files[0];
    if (files.length === 0) {
        throw new Error("Inputs missing.");
    }
    const content = await service.ReadFile(filename);
    return {
        filename,
        model: codegen_1.deserialize(content, filename, yamlSchema),
    };
}
class Session {
    /* @internal */ constructor(service) {
        this.service = service;
        this._debug = false;
        this._verbose = false;
        this.errorCount = 0;
        this.cache = new Array();
    }
    /* @internal */ async init(project, schema = js_yaml_1.DEFAULT_SCHEMA, artifactType) {
        const m = await getModel(this.service, schema, artifactType);
        this.model = m.model;
        this.filename = m.filename;
        void this.initContext(project);
        this._debug = await this.getValue("debug", false);
        this._verbose = await this.getValue("verbose", false);
        return this;
    }
    /* @internal */ async initContext(project) {
        this.context = this.context || {
            $config: await this.service.GetValue(""),
            $project: project,
            $lib: {
                path: require("path"),
            },
        };
        return this;
    }
    async readFile(filename) {
        return this.service.ReadFile(filename);
    }
    async getValue(key, defaultValue) {
        // check if it's in the model first
        const m = this.model;
        let value = m && m.language && m.language.default ? m.language.default[key] : undefined;
        // fall back to the configuration
        if (value == null || value === undefined) {
            value = await this.service.GetValue(key);
        }
        // try as a safe eval execution.
        if (value === null || value === undefined) {
            try {
                value = safeEval(key, this.context);
            }
            catch (_a) {
                value = null;
            }
        }
        if (defaultValue === undefined && value === null) {
            throw new Error(`No value for configuration key '${key}' was provided`);
        }
        if (typeof value === "string") {
            value = await this.resolveVariables(value);
        }
        // ensure that any content variables are resolved at the end.
        return (value !== null ? value : defaultValue);
    }
    async setValue(key, value) {
        this.model.language.default[key] = value;
    }
    async listInputs(artifactType) {
        return this.service.ListInputs(artifactType);
    }
    async protectFiles(path) {
        return this.service.ProtectFiles(path);
    }
    writeFile(filename, content, sourceMap, artifactType) {
        return this.service.WriteFile(filename, content, sourceMap, artifactType);
    }
    message(message) {
        if (message.Channel === types_1.Channel.Debug && this._debug === false) {
            return;
        }
        if (message.Channel === types_1.Channel.Verbose && this._verbose === false) {
            return;
        }
        return this.service.Message(message);
    }
    updateConfigurationFile(filename, content) {
        return this.service.UpdateConfigurationFile(filename, content);
    }
    async getConfigurationFile(filename) {
        return this.service.GetConfigurationFile(filename);
    }
    static async getModel(service) {
        const files = await service.ListInputs();
        const filename = files[0];
        if (files.length === 0) {
            throw new Error("Inputs missing.");
        }
        return {
            filename,
            model: codegen_1.deserialize(await service.ReadFile(filename), filename),
        };
    }
    replacer(key, value) {
        if (typeof value === "object" && value !== null) {
            if (this.cache.indexOf(value) !== -1) {
                // Duplicate reference found
                try {
                    // If this value does not reference a parent it can be deduped
                    return JSON.parse(JSON.stringify(value));
                }
                catch (error) {
                    // discard key if value cannot be deduped
                    return;
                }
            }
            // Store value in our collection
            this.cache.push(value);
        }
        return value;
    }
    async resolveVariables(input) {
        let output = input;
        for (const rx of [/\$\((.*?)\)/g, /\$\{(.*?)\}/g]) {
            /* eslint-disable */
            for (let match; (match = rx.exec(input));) {
                const text = match[0];
                const inner = match[1];
                let value = await this.getValue(inner, null);
                if (value !== undefined && value !== null) {
                    if (typeof value === "object") {
                        value = JSON.stringify(value, this.replacer, 2);
                    }
                    if (value === "{}") {
                        value = "true";
                    }
                    output = output.replace(text, value);
                }
            }
        }
        return output;
    }
    checkpoint() {
        if (this.errorCount > 0) {
            throw new Error(`${this.errorCount} errors occured -- cannot continue.`);
        }
    }
    msg(channel, message, key, objectOrPath, details) {
        const sourcePosition = objectOrPath ? objectOrPath["_#get-position#_"] || String(objectOrPath) : undefined;
        if (objectOrPath && objectOrPath["_#get-position#_"])
            this.message({
                Channel: channel,
                Key: key,
                Source: [sourcePosition],
                Text: message,
                Details: details,
            });
        else {
            this.message({
                Channel: channel,
                Key: key,
                Source: [],
                Text: message,
                Details: details,
            });
        }
    }
    warning(message, key, objectOrPath, details) {
        this.msg(types_1.Channel.Warning, message, key, objectOrPath, details);
    }
    hint(message, key, objectOrPath, details) {
        this.msg(types_1.Channel.Hint, message, key, objectOrPath, details);
    }
    error(message, key, objectOrPath, details) {
        this.errorCount++;
        this.msg(types_1.Channel.Error, message, key, objectOrPath, details);
    }
    fatal(message, key, objectOrPath, details) {
        this.errorCount++;
        this.msg(types_1.Channel.Fatal, message, key, objectOrPath, details);
    }
    output(channel, message, details) {
        this.message({
            Channel: channel,
            Text: message,
            Details: details,
        });
    }
    debug(message, details) {
        this.output(types_1.Channel.Debug, message, details);
    }
    verbose(message, details) {
        this.output(types_1.Channel.Verbose, message, details);
    }
    log(message, details) {
        this.output(types_1.Channel.Information, message, details);
    }
}
exports.Session = Session;
async function startSession(service, project, schema = js_yaml_1.DEFAULT_SCHEMA, artifactType) {
    return await new Session(service).init(project, schema, artifactType);
}
exports.startSession = startSession;
//# sourceMappingURL=convenience.js.map