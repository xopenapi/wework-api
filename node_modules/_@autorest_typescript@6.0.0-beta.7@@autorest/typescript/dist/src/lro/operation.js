"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericPollOperation = void 0;
const requestUtils_1 = require("./requestUtils");
const stateMachine_1 = require("./stateMachine");
class GenericPollOperation {
    constructor(state, lro) {
        this.state = state;
        this.lro = lro;
    }
    setPollerConfig(pollerConfig) {
        this.pollerConfig = pollerConfig;
    }
    /**
     * General update function for LROPoller, the general process is as follows
     * 1. Check initial operation result to determine the strategy to use
     *  - Strategies: Location, Azure-AsyncOperation, Original Uri
     * 2. Check if the operation result has a terminal state
     *  - Terminal state will be determined by each strategy
     *  2.1 If it is terminal state Check if a final GET request is required, if so
     *      send final GET request and return result from operation. If no final GET
     *      is required, just return the result from operation.
     *      - Determining what to call for final request is responsibility of each strategy
     *  2.2 If it is not terminal state, call the polling operation and go to step 1
     *      - Determining what to call for polling is responsibility of each strategy
     *      - Strategies will always use the latest URI for polling if provided otherwise
     *        the last known one
     */
    update(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            if (!state.isStarted) {
                const initializeState = stateMachine_1.createInitializeState(state, this.lro.requestPath, this.lro.requestMethod);
                yield this.lro.sendInitialRequest(initializeState);
            }
            if (!state.isCompleted) {
                if (this.getLROStatusFromResponse === undefined) {
                    if (state.config === undefined) {
                        throw new Error("Bad state: LRO mode is undefined. Please check if the serialized state is well-formed.");
                    }
                    this.getLROStatusFromResponse = stateMachine_1.createPollForLROStatus(this.lro, state.config);
                }
                if (state.pollingURL === undefined) {
                    throw new Error("Bad state: polling URL is undefined. Please check if the serialized state is well-formed.");
                }
                const currentState = yield this.getLROStatusFromResponse(state.pollingURL, this.pollerConfig);
                if (currentState.done) {
                    state.result = currentState.flatResponse;
                    state.isCompleted = true;
                }
                else {
                    this.getLROStatusFromResponse =
                        (_a = currentState.next) !== null && _a !== void 0 ? _a : this.getLROStatusFromResponse;
                    state.pollingURL = requestUtils_1.getPollingUrl(currentState.rawResponse, state.pollingURL);
                }
            }
            (_b = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _b === void 0 ? void 0 : _b.call(options, state);
            return this;
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.isCancelled = true;
            return this;
        });
    }
    /**
     * Serializes the Poller operation.
     */
    toString() {
        return JSON.stringify({
            state: this.state
        });
    }
}
exports.GenericPollOperation = GenericPollOperation;
//# sourceMappingURL=operation.js.map