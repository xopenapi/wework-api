"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInitializeState = exports.createPollForLROStatus = exports.createGetLroStatusFromResponse = void 0;
const azureAsyncPolling_1 = require("./azureAsyncPolling");
const bodyPolling_1 = require("./bodyPolling");
const locationPolling_1 = require("./locationPolling");
const passthrough_1 = require("./passthrough");
const requestUtils_1 = require("./requestUtils");
/**
 * creates a stepping function that maps an LRO state to another.
 */
function createGetLroStatusFromResponse(lroPrimitives, config, lroResourceLocationConfig) {
    switch (config.mode) {
        case "AzureAsync": {
            return azureAsyncPolling_1.processAzureAsyncOperationResult(lroPrimitives, config.resourceLocation, lroResourceLocationConfig);
        }
        case "Location": {
            return locationPolling_1.processLocationPollingOperationResult;
        }
        case "Body": {
            return bodyPolling_1.processBodyPollingOperationResult;
        }
        default: {
            return passthrough_1.processPassthroughOperationResult;
        }
    }
}
exports.createGetLroStatusFromResponse = createGetLroStatusFromResponse;
/**
 * Creates a polling operation that returns a LRO state.
 */
function createPollForLROStatus(lroPrimitives, config) {
    return (path, pollerConfig) => __awaiter(this, void 0, void 0, function* () {
        const response = yield lroPrimitives.sendPollRequest(config, path);
        const retryAfter = response.rawResponse.headers["retry-after"];
        if (retryAfter !== undefined) {
            const retryAfterInMs = parseInt(retryAfter);
            pollerConfig.intervalInMs = isNaN(retryAfterInMs)
                ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs)
                : retryAfterInMs;
        }
        return response;
    });
}
exports.createPollForLROStatus = createPollForLROStatus;
function calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
        return retryAfterTime - timeNow;
    }
    return defaultIntervalInMs;
}
/**
 * Creates a callback to be used to initialize the polling operation state.
 * @param state - of the polling operation
 * @param operationSpec - of the LRO
 * @param callback - callback to be called when the operation is done
 * @returns callback that initializes the state of the polling operation
 */
function createInitializeState(state, requestPath, requestMethod) {
    return (rawResponse, flatResponse) => {
        if (requestUtils_1.isUnexpectedInitialResponse(rawResponse))
            return true;
        state.initialRawResponse = rawResponse;
        state.isStarted = true;
        state.pollingURL = requestUtils_1.getPollingUrl(state.initialRawResponse, requestPath);
        state.config = requestUtils_1.inferLroMode(requestPath, requestMethod, state.initialRawResponse);
        /** short circuit polling if body polling is done in the initial request */
        if (state.config.mode === undefined ||
            (state.config.mode === "Body" && bodyPolling_1.isBodyPollingDone(state.initialRawResponse))) {
            state.result = flatResponse;
            state.isCompleted = true;
        }
        return Boolean(state.isCompleted);
    };
}
exports.createInitializeState = createInitializeState;
//# sourceMappingURL=stateMachine.js.map