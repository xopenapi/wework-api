import { AbortSignalLike } from "@azure/abort-controller";
import { PollOperationState, PollOperation } from "@azure/core-lro";
import { PollerConfig, ResumablePollOperationState, LongRunningOperation } from "./models";
export declare class GenericPollOperation<TResult, TState extends PollOperationState<TResult>> implements PollOperation<TState, TResult> {
    state: TState & ResumablePollOperationState<TResult>;
    private lro;
    private getLROStatusFromResponse?;
    private pollerConfig?;
    constructor(state: TState & ResumablePollOperationState<TResult>, lro: LongRunningOperation<TResult>);
    setPollerConfig(pollerConfig: PollerConfig): void;
    /**
     * General update function for LROPoller, the general process is as follows
     * 1. Check initial operation result to determine the strategy to use
     *  - Strategies: Location, Azure-AsyncOperation, Original Uri
     * 2. Check if the operation result has a terminal state
     *  - Terminal state will be determined by each strategy
     *  2.1 If it is terminal state Check if a final GET request is required, if so
     *      send final GET request and return result from operation. If no final GET
     *      is required, just return the result from operation.
     *      - Determining what to call for final request is responsibility of each strategy
     *  2.2 If it is not terminal state, call the polling operation and go to step 1
     *      - Determining what to call for polling is responsibility of each strategy
     *      - Strategies will always use the latest URI for polling if provided otherwise
     *        the last known one
     */
    update(options?: {
        abortSignal?: AbortSignalLike | undefined;
        fireProgress?: ((state: TState) => void) | undefined;
    }): Promise<PollOperation<TState, TResult>>;
    cancel(): Promise<PollOperation<TState, TResult>>;
    /**
     * Serializes the Poller operation.
     */
    toString(): string;
}
//# sourceMappingURL=operation.d.ts.map