import { HttpOperationResponse, OperationArguments, OperationSpec } from "@azure/core-http";
import { LroResourceLocationConfig, GetLroStatusFromResponse, LongRunningOperation, LroConfig, LroMode, LroResponse, LroStatus, RawResponse } from "./lro";
export declare const successStates: string[];
export declare const failureStates: string[];
export declare const terminalStates: string[];
export declare type SendOperationFn<T> = (args: OperationArguments, spec: OperationSpec) => Promise<LroResponse<T>>;
export declare function createPollingMethod<TResult>(sendOperationFn: SendOperationFn<TResult>, getLroStatusFromResponse: GetLroStatusFromResponse<TResult>, args: OperationArguments, spec: OperationSpec, mode?: LroMode): (path?: string) => Promise<LroStatus<TResult>>;
/**
 * We need to selectively deserialize our responses, only deserializing if we
 * are in a final Lro response, not deserializing any polling non-terminal responses
 */
export declare function shouldDeserializeLro(lroResourceLocationConfig?: string): (response: HttpOperationResponse) => boolean;
export declare function getSpecPath(spec: OperationSpec): string;
export declare class CoreHttpLro<T> implements LongRunningOperation<T> {
    private sendOperationFn;
    private args;
    private spec;
    private lroResourceLocationConfig?;
    requestPath: string;
    requestMethod: string;
    constructor(sendOperationFn: SendOperationFn<T>, args: OperationArguments, spec: OperationSpec, lroResourceLocationConfig?: LroResourceLocationConfig | undefined, requestPath?: string, requestMethod?: string);
    sendInitialRequest(initializeState: (rawResponse: RawResponse, flatResponse: unknown) => boolean): Promise<LroResponse<T>>;
    sendPollRequest(config: LroConfig, path: string): Promise<LroStatus<T>>;
    retrieveAzureAsyncResource(path?: string): Promise<LroResponse<T>>;
}
//# sourceMappingURL=coreHttpLro.d.ts.map