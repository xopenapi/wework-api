"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreClientLro = exports.getSpecPath = exports.shouldDeserializeLro = exports.createPollingMethod = exports.terminalStates = exports.failureStates = exports.successStates = void 0;
const lro_1 = require("./lro");
exports.successStates = ["succeeded"];
exports.failureStates = ["failed", "canceled", "cancelled"];
exports.terminalStates = exports.successStates.concat(exports.failureStates);
function createPollingMethod(sendOperationFn, GetLroStatusFromResponse, args, spec, mode) {
    var _a;
    /**
     * Polling calls will always return a status object i.e. {"status": "success"}
     * these intermediate responses are not described in the swagger so we need to
     * pass custom mappers at runtime.
     * This function replaces all the existing mappers to be able to deserialize a status object
     * @param responses Original set of responses defined in the operation
     */
    function getCompositeMappers(responses) {
        return Object.keys(responses).reduce((acc, statusCode) => {
            return Object.assign(Object.assign({}, acc), { [statusCode]: Object.assign(Object.assign({}, responses[statusCode]), { bodyMapper: {
                        type: {
                            name: "Composite",
                            modelProperties: {
                                status: {
                                    serializedName: "status",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    } }) });
        }, {});
    }
    let response = undefined;
    const customerCallback = (_a = args === null || args === void 0 ? void 0 : args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
    const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: (rawResponse, flatResponse) => {
                response = GetLroStatusFromResponse({
                    statusCode: rawResponse.status,
                    body: rawResponse.parsedBody,
                    headers: rawResponse.headers.toJSON()
                }, flatResponse);
                if (response.done) {
                    customerCallback === null || customerCallback === void 0 ? void 0 : customerCallback(rawResponse, flatResponse);
                }
            } }) });
    // Make sure we don't send any body to the get request
    const { requestBody, responses } = spec, restSpec = __rest(spec, ["requestBody", "responses"]);
    if (mode === "AzureAsync") {
        return (path) => __awaiter(this, void 0, void 0, function* () {
            yield sendOperationFn(updatedArgs, Object.assign(Object.assign(Object.assign({}, restSpec), { responses: getCompositeMappers(responses), httpMethod: "GET" }), (path && { path })));
            return response;
        });
    }
    return (path) => __awaiter(this, void 0, void 0, function* () {
        yield sendOperationFn(updatedArgs, Object.assign(Object.assign(Object.assign({}, restSpec), { responses: responses, httpMethod: "GET" }), (path && { path })));
        return response;
    });
}
exports.createPollingMethod = createPollingMethod;
/**
 * We need to selectively deserialize our responses, only deserializing if we
 * are in a final Lro response, not deserializing any polling non-terminal responses
 */
function shouldDeserializeLro(lroResourceLocationConfig) {
    let initialOperationInfo;
    let isInitialRequest = true;
    return (response) => {
        if (response.status < 200 || response.status >= 300) {
            return true;
        }
        if (!initialOperationInfo) {
            initialOperationInfo = getLroData(response);
        }
        else {
            isInitialRequest = false;
        }
        if (initialOperationInfo.azureAsyncOperation ||
            initialOperationInfo.operationLocation) {
            return (!isInitialRequest &&
                isAsyncOperationFinalResponse(response, initialOperationInfo, lroResourceLocationConfig));
        }
        if (initialOperationInfo.location) {
            return isLocationFinalResponse(response);
        }
        if (initialOperationInfo.requestMethod === "PUT") {
            return isBodyPollingFinalResponse(response);
        }
        return true;
    };
}
exports.shouldDeserializeLro = shouldDeserializeLro;
function isAsyncOperationFinalResponse(response, initialOperationInfo, lroResourceLocationConfig) {
    var _a;
    const status = ((_a = response.parsedBody) === null || _a === void 0 ? void 0 : _a.status) || "Succeeded";
    if (!exports.terminalStates.includes(status.toLowerCase())) {
        return false;
    }
    if (initialOperationInfo.requestMethod === "DELETE") {
        return true;
    }
    if (initialOperationInfo.requestMethod === "PUT" &&
        lroResourceLocationConfig &&
        lroResourceLocationConfig.toLowerCase() === "azure-asyncoperation") {
        return true;
    }
    if (initialOperationInfo.requestMethod !== "PUT" &&
        !initialOperationInfo.location) {
        return true;
    }
    return false;
}
function isLocationFinalResponse(response) {
    return response.status !== 202;
}
function isBodyPollingFinalResponse(response) {
    var _a, _b;
    const provisioningState = ((_b = (_a = response.parsedBody) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.provisioningState) || "Succeeded";
    if (exports.terminalStates.includes(provisioningState.toLowerCase())) {
        return true;
    }
    return false;
}
function getLroData(result) {
    return {
        azureAsyncOperation: result.headers.get("azure-asyncoperation"),
        operationLocation: result.headers.get("operation-location"),
        location: result.headers.get("location"),
        requestMethod: result.request.method
    };
}
function getSpecPath(spec) {
    if (spec.path) {
        return spec.path;
    }
    else {
        throw Error("Bad spec: request path is not found!");
    }
}
exports.getSpecPath = getSpecPath;
class CoreClientLro {
    constructor(sendOperationFn, args, spec, lroResourceLocationConfig, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.lroResourceLocationConfig = lroResourceLocationConfig;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest(initializeState) {
        return __awaiter(this, void 0, void 0, function* () {
            const _a = this.args.options || {}, { onResponse } = _a, restOptions = __rest(_a, ["onResponse"]);
            return this.sendOperationFn(Object.assign(Object.assign({}, this.args), { options: Object.assign(Object.assign({}, restOptions), { onResponse: (rawResponse, flatResponse) => {
                        const isCompleted = initializeState({
                            statusCode: rawResponse.status,
                            body: rawResponse.parsedBody,
                            headers: rawResponse.headers.toJSON()
                        }, flatResponse);
                        if (isCompleted) {
                            onResponse === null || onResponse === void 0 ? void 0 : onResponse(rawResponse, flatResponse);
                        }
                    } }) }), this.spec);
        });
    }
    sendPollRequest(config, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const getLroStatusFromResponse = lro_1.createGetLroStatusFromResponse(this, config, this.lroResourceLocationConfig);
            return createPollingMethod(this.sendOperationFn, getLroStatusFromResponse, this.args, this.spec, config.mode)(path);
        });
    }
    retrieveAzureAsyncResource(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const updatedArgs = Object.assign({}, this.args);
            if (updatedArgs.options) {
                updatedArgs.options.shouldDeserialize = true;
            }
            return createPollingMethod(this.sendOperationFn, (rawResponse, flatResponse) => ({
                rawResponse,
                flatResponse,
                done: true
            }), updatedArgs, this.spec)(path);
        });
    }
}
exports.CoreClientLro = CoreClientLro;
//# sourceMappingURL=coreClientLro.js.map