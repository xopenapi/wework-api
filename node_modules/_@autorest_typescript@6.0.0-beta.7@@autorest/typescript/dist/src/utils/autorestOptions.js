"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCredentialScopes = exports.extractAutorestOptions = void 0;
const extension_base_1 = require("@autorest/extension-base");
const autorestSession_1 = require("../autorestSession");
const nameUtils_1 = require("./nameUtils");
/**
 * Extracts common autorest options
 */
function extractAutorestOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const host = autorestSession_1.getHost();
        const useCoreV2 = yield getUseCoreV2(host);
        const restLevelClient = yield getRestLevelClient(host);
        const azureArm = yield getIsAzureArm(host);
        const addCredentials = yield getAddCredentials(host);
        const credentialKeyHeaderName = yield getKeyCredentialHeaderName(host);
        const srcPath = yield getSrcPath(host);
        const outputPath = yield getOutputPath(host);
        const credentialScopes = yield getCredentialScopes(host);
        const packageDetails = yield getPackageDetails(host);
        const licenseHeader = yield getLicenseHeader(host);
        const generateMetadata = yield getGenerateMetadata(host);
        const hideClients = yield getHideClients(host);
        const title = yield getTitle(host);
        const tracingInfo = yield getTracingInfo(host);
        const disablePagingAsyncIterators = yield getDisableAsyncOperators(host);
        const ignoreNullableOnOptional = yield getIgnoreNullableOnOptional(host);
        const allowInsecureConnection = yield getAllowInsecureConnection(host);
        const skipEnumValidation = yield getSkipEnumValidation(host);
        const azureOutputDirectory = yield getAzureOutputDirectoryPath(host);
        const headAsBoolean = yield getHeadAsBoolean(host);
        return {
            azureArm,
            addCredentials,
            credentialKeyHeaderName,
            credentialScopes,
            restLevelClient,
            srcPath,
            outputPath,
            packageDetails,
            licenseHeader,
            tracingInfo,
            generateMetadata,
            useCoreV2,
            hideClients,
            ignoreNullableOnOptional,
            allowInsecureConnection,
            disablePagingAsyncIterators,
            skipEnumValidation,
            title,
            azureOutputDirectory,
            headAsBoolean
        };
    });
}
exports.extractAutorestOptions = extractAutorestOptions;
function getHeadAsBoolean(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const headAsBoolean = yield host.GetValue("head-as-boolean");
        return Boolean(headAsBoolean);
    });
}
function getSkipEnumValidation(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const skipEnumValidation = yield host.GetValue("skip-enum-validation");
        return skipEnumValidation === true;
    });
}
function getAllowInsecureConnection(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("allow-insecure-connection")) || false;
    });
}
function getIgnoreNullableOnOptional(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const isAzureArm = yield getIsAzureArm(host);
        return (yield host.GetValue("ignore-nullable-on-optional"))
            ? true
            : isAzureArm;
    });
}
function getDisableAsyncOperators(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("disable-async-iterators")) === true;
    });
}
function getHideClients(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("hide-clients")) || false;
    });
}
function getGenerateMetadata(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("generate-metadata")) !== false;
    });
}
function getLicenseHeader(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("license-header")) || false;
    });
}
function getTitle(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("title")) || undefined;
    });
}
function getSrcPath(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("source-code-folder-path")) || "src";
    });
}
function getOutputPath(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("output-folder")) || undefined;
    });
}
function getKeyCredentialHeaderName(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("credential-key-header-name")) || undefined;
    });
}
function getAddCredentials(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const addCredentials = yield host.GetValue("add-credentials");
        // Only set addCredentials to false if explicitly set to false
        // otherwise default to true
        if (addCredentials === false) {
            return false;
        }
        else {
            return true;
        }
    });
}
function getIsAzureArm(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const flag = (yield host.GetValue("azure-arm")) === true;
        const openapi = (yield host.GetValue("openapi-type")) === "arm";
        return flag || openapi;
    });
}
function getRestLevelClient(host) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield host.GetValue("rest-level-client")) === true;
    });
}
function getUseCoreV2(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const useCoreV2Option = yield host.GetValue("use-core-v2");
        return useCoreV2Option === null ? true : Boolean(useCoreV2Option);
    });
}
function getTracingInfo(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const tracing = (yield host.GetValue("tracing-info")) || undefined;
        if (tracing && tracing.namespace && tracing.packagePrefix) {
            return tracing;
        }
        const namespace = (yield host.GetValue("tracing-info.namespace")) || undefined;
        const packagePrefix = (yield host.GetValue("tracing-info.packagePrefix")) || undefined;
        if (packagePrefix && namespace) {
            return {
                namespace,
                packagePrefix
            };
        }
        if (!tracing && !packagePrefix && !namespace) {
            return undefined;
        }
        throw new Error("Invalid tracing-info. Make sure that namespace and packagePrefix are defined");
    });
}
function getPackageDetails(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const { model } = autorestSession_1.getSession();
        const name = nameUtils_1.normalizeName(model.language.default.name, nameUtils_1.NameType.File);
        // TODO: Look for an existing package.json and
        const packageName = (yield host.GetValue("package-name")) || name;
        const packageNameParts = packageName.match(/(^@(.*)\/)?(.*)/);
        const version = (yield host.GetValue("package-version")) || "1.0.0-beta.1";
        return {
            name: packageName,
            scopeName: packageNameParts[2],
            nameWithoutScope: packageNameParts[3],
            description: model.language.default.description,
            version
        };
    });
}
function getCredentialScopes(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const addCredentials = yield host.GetValue("add-credentials");
        const credentialScopes = yield host.GetValue("credential-scopes");
        const azureArm = yield host.GetValue("azure-arm");
        if (credentialScopes && !addCredentials) {
            throw new Error("--credential-scopes must be used with the --add-credentials flag");
        }
        if (!credentialScopes) {
            if (azureArm) {
                return ["https://management.azure.com/.default"];
            }
            else if (addCredentials) {
                host.Message({
                    Channel: extension_base_1.Channel.Warning,
                    Text: `You have default credential policy BearerTokenCredentialPolicy
        but not the --credential-scopes flag set while generating non-management plane code.
        This is not recommended because it forces the customer to pass credential scopes
        through kwargs if they want to authenticate.`
                });
            }
        }
        if (typeof credentialScopes === "string") {
            return credentialScopes.split(",");
        }
        return undefined;
    });
}
exports.getCredentialScopes = getCredentialScopes;
function getAzureOutputDirectoryPath(host) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputDirectoryPath = yield host.GetValue("outputFolderUri");
        const outputDirectoryRelativePath = outputDirectoryPath === null || outputDirectoryPath === void 0 ? void 0 : outputDirectoryPath.replace(/\/$/, "").split("/").slice(-3).join("/");
        return (outputDirectoryRelativePath === null || outputDirectoryRelativePath === void 0 ? void 0 : outputDirectoryRelativePath.substr(0, 3)) === "sdk"
            ? outputDirectoryRelativePath
            : undefined;
    });
}
//# sourceMappingURL=autorestOptions.js.map