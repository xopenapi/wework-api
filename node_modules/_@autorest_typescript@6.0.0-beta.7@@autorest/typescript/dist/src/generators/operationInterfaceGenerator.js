"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeOperations = exports.generateOperationsInterfaces = void 0;
const ts_morph_1 = require("ts-morph");
const nameUtils_1 = require("../utils/nameUtils");
const parameterUtils_1 = require("./utils/parameterUtils");
const responseTypeUtils_1 = require("./utils/responseTypeUtils");
const docsUtils_1 = require("./utils/docsUtils");
const tracingUtils_1 = require("./utils/tracingUtils");
const pagingOperations_1 = require("./utils/pagingOperations");
const operationsUtils_1 = require("./utils/operationsUtils");
const autorestSession_1 = require("../autorestSession");
/**
 * Function that writes the code for all the operations.
 * It will generate one file per operation group and each file contains:
 *    - A class definition for the operation group
 *    - Methods and overrides for each operation
 *    - OperationSpecs for each operation
 * @param clientDetails client details
 * @param project project for code generation
 */
function generateOperationsInterfaces(clientDetails, project) {
    const { srcPath } = autorestSession_1.getAutorestOptions();
    let fileNames = [];
    // Toplevel operations are inlined in the client
    const operationGroups = clientDetails.operationGroups.filter(og => !og.isTopLevel);
    operationGroups.forEach(operationDetails => {
        fileNames.push(nameUtils_1.normalizeName(operationDetails.name, nameUtils_1.NameType.File));
        generateOperation(operationDetails, clientDetails, project);
    });
    if (operationGroups.length) {
        const operationIndexFile = project.createSourceFile(`${srcPath}/operationsInterfaces/index.ts`, undefined, { overwrite: true });
        operationIndexFile.addExportDeclarations(fileNames.map(fileName => {
            return {
                moduleSpecifier: `./${fileName}`
            };
        }));
    }
}
exports.generateOperationsInterfaces = generateOperationsInterfaces;
/**
 * This function creates a file for a given Operation Group
 */
function generateOperation(operationGroupDetails, clientDetails, project) {
    const { srcPath } = autorestSession_1.getAutorestOptions();
    const name = nameUtils_1.normalizeName(operationGroupDetails.name, nameUtils_1.NameType.File);
    const operationInterfaceGroupFile = project.createSourceFile(`${srcPath}/operationsInterfaces/${name}.ts`, undefined, { overwrite: true });
    addImports(operationGroupDetails, operationInterfaceGroupFile, clientDetails);
    addInterface(operationInterfaceGroupFile, operationGroupDetails, clientDetails);
    operationInterfaceGroupFile.fixUnusedIdentifiers();
}
function getReturnType(operation, importedModels, modelNames) {
    const responseName = responseTypeUtils_1.getOperationResponseType(operation, importedModels, modelNames);
    return operation.isLro
        ? `Promise<PollerLike<PollOperationState<${responseName}>,${responseName}>>`
        : `Promise<${responseName}>`;
}
/**
 * Adds an Operation group interface to the generated file
 */
function addInterface(operationGroupFile, operationGroupDetails, clientDetails) {
    let importedModels = new Set();
    let allModelsNames = responseTypeUtils_1.getAllModelsNames(clientDetails);
    const interfaceName = nameUtils_1.normalizeName(operationGroupDetails.name, nameUtils_1.NameType.OperationGroup, true /** shouldGuard */);
    const operationGroupClass = operationGroupFile.addInterface({
        name: interfaceName,
        docs: [`Interface representing a ${interfaceName}.`],
        isExported: true
    });
    writeOperations(operationGroupDetails, operationGroupClass, importedModels, allModelsNames, clientDetails);
    // Use named import from Models
    if (importedModels.size) {
        // Add alias to any model that collides with the class name
        const namedImports = [...importedModels].map(model => {
            if (model === interfaceName) {
                return `${model} as ${model}Model`;
            }
            return model;
        });
        operationGroupFile.addImportDeclaration({
            namedImports,
            moduleSpecifier: "../models"
        });
    }
}
/**
 * Write operations signatures, extracted from OperationGroupDetails, to the generated file
 */
function writeOperations(operationGroupDetails, operationGroupInterface, importedModels, modelNames, clientDetails) {
    pagingOperations_1.preparePageableOperations(operationGroupDetails);
    pagingOperations_1.writeAsyncIterators(operationGroupDetails, clientDetails, operationGroupInterface, importedModels);
    operationGroupDetails.operations.forEach(operation => {
        if (operation.scope !== ts_morph_1.Scope.Private) {
            const { baseMethodParameters } = parameterUtils_1.getOperationParameterSignatures(operation, clientDetails.parameters, importedModels, operationGroupInterface);
            const returnType = getReturnType(operation, importedModels, modelNames);
            const name = `${operation.namePrefix || ""}${nameUtils_1.normalizeName(operation.name, nameUtils_1.NameType.Property)}`;
            operationGroupInterface.addMethod({
                name: operationsUtils_1.calculateMethodName(operation),
                parameters: baseMethodParameters,
                returnType,
                docs: [
                    docsUtils_1.generateOperationJSDoc(baseMethodParameters, operation.description)
                ]
            });
            /**
             * Create a simple method that blocks and waits for the result
             */
            if (operation.isLro && operation.pagination === undefined) {
                const responseName = responseTypeUtils_1.getOperationResponseType(operation, importedModels, modelNames);
                const methodName = operationsUtils_1.calculateMethodName(operation);
                operationGroupInterface.addMethod({
                    name: `${methodName}AndWait`,
                    parameters: baseMethodParameters,
                    returnType: `Promise<${responseName}>`,
                    docs: [
                        docsUtils_1.generateOperationJSDoc(baseMethodParameters, operation.description)
                    ]
                });
            }
        }
    });
}
exports.writeOperations = writeOperations;
/**
 * Adds required imports at the top of the file
 */
function addImports(operationGroupDetails, operationGroupFile, clientDetails) {
    const { useCoreV2 } = autorestSession_1.getAutorestOptions();
    pagingOperations_1.addPagingEsNextRef(operationGroupDetails.operations, operationGroupFile);
    tracingUtils_1.addTracingOperationImports(operationGroupFile);
    pagingOperations_1.addPagingImports(operationGroupDetails.operations, operationGroupFile);
    if (!useCoreV2) {
        operationGroupFile.addImportDeclaration({
            namespaceImport: "coreHttp",
            moduleSpecifier: "@azure/core-http"
        });
    }
    else {
        operationGroupFile.addImportDeclaration({
            namespaceImport: "coreClient",
            moduleSpecifier: "@azure/core-client"
        });
        operationGroupFile.addImportDeclaration({
            namespaceImport: "coreRestPipeline",
            moduleSpecifier: "@azure/core-rest-pipeline"
        });
    }
    if (hasLroOperation(operationGroupDetails)) {
        operationGroupFile.addImportDeclaration({
            namedImports: ["PollerLike", "PollOperationState"],
            moduleSpecifier: "@azure/core-lro"
        });
    }
}
function hasLroOperation(operationGroupDetails) {
    return operationGroupDetails.operations.some(o => o.isLro);
}
//# sourceMappingURL=operationInterfaceGenerator.js.map