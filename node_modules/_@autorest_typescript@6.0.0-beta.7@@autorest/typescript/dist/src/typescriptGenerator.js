"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypeScriptLibrary = void 0;
const prettier = require("prettier");
const ts_morph_1 = require("ts-morph");
const transforms_1 = require("./transforms/transforms");
const clientFileGenerator_1 = require("./generators/clientFileGenerator");
const clientContextFileGenerator_1 = require("./generators/clientContextFileGenerator");
const modelsGenerator_1 = require("./generators/modelsGenerator");
const mappersGenerator_1 = require("./generators/mappersGenerator");
const indexGenerator_1 = require("./generators/indexGenerator");
const packageFileGenerator_1 = require("./generators/static/packageFileGenerator");
const apiExtractorConfig_1 = require("./generators/static/apiExtractorConfig");
const licenseFileGenerator_1 = require("./generators/static/licenseFileGenerator");
const readmeFileGenerator_1 = require("./generators/static/readmeFileGenerator");
const tsConfigFileGenerator_1 = require("./generators/static/tsConfigFileGenerator");
const rollupConfigFileGenerator_1 = require("./generators/static/rollupConfigFileGenerator");
const operationGenerator_1 = require("./generators/operationGenerator");
const operationInterfaceGenerator_1 = require("./generators/operationInterfaceGenerator");
const parametersGenerator_1 = require("./generators/parametersGenerator");
const LROGenerator_1 = require("./generators/LROGenerator");
const tracingFileGenerator_1 = require("./generators/tracingFileGenerator");
const autorestSession_1 = require("./autorestSession");
const prettierTypeScriptOptions = {
    parser: "typescript",
    arrowParens: "always",
    bracketSpacing: true,
    endOfLine: "lf",
    printWidth: 80,
    semi: true,
    singleQuote: false,
    tabWidth: 2
};
const prettierJSONOptions = {
    parser: "json",
    tabWidth: 2,
    semi: false,
    singleQuote: false
};
function generateTypeScriptLibrary(codeModel, host) {
    return __awaiter(this, void 0, void 0, function* () {
        const project = new ts_morph_1.Project({
            useInMemoryFileSystem: true,
            manipulationSettings: {
                indentationText: ts_morph_1.IndentationText.TwoSpaces
            }
        });
        const { packageDetails, licenseHeader: shouldGenerateLicense } = autorestSession_1.getAutorestOptions();
        const clientDetails = yield transforms_1.transformCodeModel(codeModel, host);
        clientDetails.operationGroups.forEach(operationGroup => {
            const isConflict = checkForConflictWithDefinitions(operationGroup.name, clientDetails);
            if (isConflict) {
                operationGroup.operations.forEach(operation => {
                    operation.typeDetails.typeName = operation.typeDetails.typeName.replace(operationGroup.name, `${operationGroup.name}Operations`);
                });
                operationGroup.name = `${operationGroup.name}Operations`;
                operationGroup.key = `${operationGroup.key}Operations`;
            }
        });
        // Skip metadata generation if `generate-metadata` is explicitly false
        packageFileGenerator_1.generatePackageJson(project, clientDetails);
        licenseFileGenerator_1.generateLicenseFile(project);
        readmeFileGenerator_1.generateReadmeFile(clientDetails, project);
        tsConfigFileGenerator_1.generateTsConfig(project);
        rollupConfigFileGenerator_1.generateRollupConfig(project);
        apiExtractorConfig_1.generateApiExtractorConfig(project);
        clientFileGenerator_1.generateClient(clientDetails, project);
        clientContextFileGenerator_1.generateClientContext(clientDetails, packageDetails, project);
        modelsGenerator_1.generateModels(clientDetails, project);
        mappersGenerator_1.generateMappers(clientDetails, project);
        operationGenerator_1.generateOperations(clientDetails, project);
        operationInterfaceGenerator_1.generateOperationsInterfaces(clientDetails, project);
        parametersGenerator_1.generateParameters(clientDetails, project);
        indexGenerator_1.generateIndexFile(clientDetails, project);
        yield LROGenerator_1.generateLroFiles(clientDetails, project);
        tracingFileGenerator_1.generateTracingFile(project);
        const licenseHeader = `
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
`;
        // Save the source files to the virtual filesystem
        project.saveSync();
        const fs = project.getFileSystem();
        // Loop over the files
        for (const file of project.getSourceFiles()) {
            const filePath = file.getFilePath();
            const isJson = /\.json$/gi.test(filePath);
            const isSourceCode = /\.(ts|js)$/gi.test(filePath);
            let fileContents = fs.readFileSync(filePath);
            // Add the license header to source code files
            if (shouldGenerateLicense && isSourceCode) {
                fileContents = `${licenseHeader.trimLeft()}\n${fileContents}`;
            }
            // Format the contents if necessary
            if (isJson || isSourceCode) {
                fileContents = prettier.format(fileContents, isJson ? prettierJSONOptions : prettierTypeScriptOptions);
            }
            // Write the file to the AutoRest host
            host.WriteFile(filePath.substr(1), // Get rid of the leading slash '/'
            fileContents);
        }
    });
}
exports.generateTypeScriptLibrary = generateTypeScriptLibrary;
function checkForConflictWithDefinitions(operationGroupName, clientDetails) {
    let conflict = false;
    clientDetails.objects.forEach(model => {
        if (model.name === operationGroupName) {
            conflict = true;
        }
    });
    return conflict;
}
//# sourceMappingURL=typescriptGenerator.js.map