"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPolymorphicAliases = exports.buildObjectInterfaces = void 0;
const codemodel_1 = require("@autorest/codemodel");
const extension_base_1 = require("@autorest/extension-base");
const ts_morph_1 = require("ts-morph");
const autorestSession_1 = require("../autorestSession");
const nameUtils_1 = require("../utils/nameUtils");
const schemaHelpers_1 = require("./schemaHelpers");
const getPropertySignature_1 = require("./getPropertySignature");
const languageHelpers_1 = require("../utils/languageHelpers");
/**
 * Generates interfaces for ObjectSchemas
 */
function buildObjectInterfaces(model, importedModels) {
    var _a;
    const objectSchemas = (_a = model.schemas.objects) !== null && _a !== void 0 ? _a : [];
    const objectInterfaces = [];
    for (const objectSchema of objectSchemas) {
        const baseName = getObjectBaseName(objectSchema);
        const interfaceDeclaration = getObjectInterfaceDeclaration(baseName, objectSchema, importedModels);
        objectInterfaces.push(interfaceDeclaration);
    }
    return objectInterfaces;
}
exports.buildObjectInterfaces = buildObjectInterfaces;
function buildPolymorphicAliases(model) {
    var _a;
    // We'll add aliases for polymorphic objects
    const objectAliases = [];
    const objectSchemas = (_a = model.schemas.objects) !== null && _a !== void 0 ? _a : [];
    for (const objectSchema of objectSchemas) {
        const baseName = getObjectBaseName(objectSchema);
        const typeAlias = getPolymorphicTypeAlias(baseName, objectSchema);
        if (typeAlias) {
            objectAliases.push(typeAlias);
        }
    }
    return objectAliases;
}
exports.buildPolymorphicAliases = buildPolymorphicAliases;
/**
 * Gets a base name for an object schema this is tipically used with suffixes when building interface or type names
 */
function getObjectBaseName(objectSchema) {
    return nameUtils_1.normalizeName(languageHelpers_1.getLanguageMetadata(objectSchema.language).name, nameUtils_1.NameType.Interface, true /** guard name */);
}
/**
 * If the current object is a Polymorphic parent, we need to create
 * a type alias with the union of its children to enable polymorphism
 */
function getPolymorphicTypeAlias(baseName, objectSchema) {
    var _a, _b;
    if (!isPolymorphicParent(objectSchema)) {
        return undefined;
    }
    const unionTypes = [];
    // If the object itself has a discriminatorValue add its base to the union
    if (objectSchema.discriminatorValue) {
        unionTypes.push(`${baseName}Base`);
    }
    for (const child of (_b = (_a = objectSchema.children) === null || _a === void 0 ? void 0 : _a.all) !== null && _b !== void 0 ? _b : []) {
        const name = nameUtils_1.normalizeName(languageHelpers_1.getLanguageMetadata(child.language).name, nameUtils_1.NameType.Interface, true /** shouldGuard */);
        unionTypes.push(name);
    }
    return {
        kind: ts_morph_1.StructureKind.TypeAlias,
        name: baseName,
        type: unionTypes.join(" | "),
        isExported: true
    };
}
/**
 * Builds the interface for the current object schema. If it is a polymorphic
 * root node it will suffix it with Base.
 */
function getObjectInterfaceDeclaration(baseName, objectSchema, importedModels) {
    var _a;
    let interfaceName = baseName;
    if (isPolymorphicParent(objectSchema)) {
        interfaceName = `${baseName}Base`;
    }
    const properties = (_a = objectSchema.properties) !== null && _a !== void 0 ? _a : [];
    let propertySignatures = getPropertySignatures(properties, importedModels);
    // Add the polymorphic property if exists
    propertySignatures = addDiscriminatorProperty(objectSchema, propertySignatures);
    // Calculate the parents of the current object
    const extendFrom = getImmediateParentsNames(objectSchema);
    return Object.assign({ kind: ts_morph_1.StructureKind.Interface, name: interfaceName, isExported: true, properties: propertySignatures }, (extendFrom && { extends: extendFrom }));
}
function isPolymorphicParent(objectSchema) {
    var _a;
    return ((_a = objectSchema.children) === null || _a === void 0 ? void 0 : _a.immediate.length) && objectSchema.discriminator;
}
function addDiscriminatorProperty(objectSchema, properties) {
    const polymorphicProperty = getDiscriminatorProperty(objectSchema);
    if (polymorphicProperty) {
        // It is possible that the polymorphic property needs to override an existing property.
        // This is usually the case on the top level parent where the property already has a type of string
        // we need to replace it with the polymorphic values of its children
        const filteredProperties = properties.filter(p => p.name !== polymorphicProperty.name);
        return [...filteredProperties, polymorphicProperty];
    }
    return properties;
}
/**
 * Finds the name of the property used as discriminator and the discriminator value.
 */
function getDiscriminatorProperty(objectSchema) {
    const { message } = autorestSession_1.getSession();
    const discriminatorValue = objectSchema.discriminatorValue;
    if (!discriminatorValue && !objectSchema.discriminator) {
        return undefined;
    }
    const discriminators = getDiscriminatorValue(objectSchema);
    const discriminatorPropertyName = getDiscriminatorPropertyName(objectSchema);
    if (discriminators) {
        if (discriminatorPropertyName === undefined) {
            message({
                Text: `getDiscriminatorProperty: Expected object ${languageHelpers_1.getLanguageMetadata(objectSchema.language).name} to have a discriminator in its hierarchy but found none`,
                Channel: extension_base_1.Channel.Warning
            });
            return;
        }
        return {
            kind: ts_morph_1.StructureKind.PropertySignature,
            name: `"${discriminatorPropertyName}"`,
            type: discriminators
        };
    }
    return undefined;
}
/**
 * Finds the closest discriminator property
 */
function getDiscriminatorPropertyName(objectSchema) {
    var _a, _b;
    if (objectSchema.discriminator !== undefined) {
        return objectSchema.discriminator.property.serializedName;
    }
    const allParents = (_b = (_a = objectSchema.parents) === null || _a === void 0 ? void 0 : _a.all) !== null && _b !== void 0 ? _b : [];
    for (const parent of allParents) {
        if (codemodel_1.isObjectSchema(parent) && parent.discriminator) {
            return parent.discriminator.property.serializedName;
        }
    }
    return undefined;
}
/**
 * Calculates the discriminator values that a given object needs
 */
function getDiscriminatorValue(objectSchema) {
    var _a, _b, _c, _d;
    const discriminatorValue = objectSchema.discriminatorValue;
    const children = (_b = (_a = objectSchema.children) === null || _a === void 0 ? void 0 : _a.immediate) !== null && _b !== void 0 ? _b : [];
    // If the current object has a discriminatorValue but doesn't have any children
    // it is a leaf node and the only discriminator value needed is itself
    if (discriminatorValue && !children.length) {
        return `"${discriminatorValue}"`;
    }
    // when the current object has both discriminator and discriminatorValue
    if (children) {
        const discriminatorProperty = objectSchema.discriminator;
        // Even when there are children, if no discriminatorProperty is present this is a leaf in the polymorphism tree
        if (!discriminatorProperty) {
            return `"${discriminatorValue}"`;
        }
        // the current object has discriminated children we need to find all the discriminatorValues for each of its children
        const allChildren = (_d = (_c = objectSchema.children) === null || _c === void 0 ? void 0 : _c.all) !== null && _d !== void 0 ? _d : [];
        // Top level parents may not have a discriminator of their own.
        const selfDiscriminator = discriminatorValue
            ? [`"${discriminatorValue}"`]
            : [];
        const childValues = getChildDiscriminatorValues(allChildren).map(v => `"${v}"`);
        return [...selfDiscriminator, ...childValues].join(" | ");
    }
    return undefined;
}
/**
 * Looks into the children and grabs all possible discriminatorValues
 */
function getChildDiscriminatorValues(children) {
    const discriminatorValues = new Set();
    for (const child of children) {
        if (codemodel_1.isObjectSchema(child) && child.discriminatorValue) {
            discriminatorValues.add(child.discriminatorValue);
        }
    }
    return [...discriminatorValues];
}
/**
 * Gets a list of types a given object may extend from
 */
function getImmediateParentsNames(objectSchema) {
    var _a;
    if (!((_a = objectSchema.parents) === null || _a === void 0 ? void 0 : _a.immediate)) {
        return [];
    }
    let extendFrom = [];
    // If an immediate parent is a DictionarySchema, that means that the object has been marked
    // with additional properties. We need to add Record<string, unknown> to the extend list and
    if (objectSchema.parents.immediate.find(schemaHelpers_1.isDictionarySchema)) {
        extendFrom.push("Record<string, unknown>");
    }
    // Get the rest of the parents excluding any DictionarySchemas
    const parents = objectSchema.parents.immediate
        .filter(p => !schemaHelpers_1.isDictionarySchema(p))
        .map(parent => {
        const name = nameUtils_1.normalizeName(languageHelpers_1.getLanguageMetadata(parent.language).name, nameUtils_1.NameType.Interface, true /** shouldGuard */);
        return codemodel_1.isObjectSchema(parent) && isPolymorphicParent(parent)
            ? `${name}Base`
            : name;
    });
    return [...parents, ...extendFrom];
}
function getPropertySignatures(properties, importedModels) {
    return properties.map(p => getPropertySignature_1.getPropertySignature(p, importedModels));
}
//# sourceMappingURL=generateObjectTypes.js.map