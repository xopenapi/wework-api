"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateResponseInterfaces = void 0;
const operationHelpers_1 = require("./operationHelpers");
const ts_morph_1 = require("ts-morph");
const nameUtils_1 = require("../utils/nameUtils");
const schemaHelpers_1 = require("./schemaHelpers");
const languageHelpers_1 = require("../utils/languageHelpers");
function generateResponseInterfaces(model, project) {
    const responsesFile = project.createSourceFile(`src/responses.ts`, undefined, {
        overwrite: true
    });
    // Set used to track down which models need to be imported
    let importedModels = new Set();
    const operations = getAllOperationRequests(model);
    // Track if we need to import RawHttpHeaders
    let hasHeaders = false;
    for (const operation of operations) {
        const responses = mergeResponsesAndExceptions(operation);
        for (const response of responses) {
            // We'll need http information such as headers, statusCodes, etc continue if not available
            if (!response.protocol.http) {
                continue;
            }
            let schemaResponse = operationHelpers_1.responseToSchemaResponse(response);
            const statusCode = operationHelpers_1.getStatusCode(schemaResponse);
            const operationLanguageMetadata = languageHelpers_1.getLanguageMetadata(operation.language);
            // Building the response type base name
            const baseResponseName = nameUtils_1.normalizeName(`${operationLanguageMetadata.name}${statusCode}`, nameUtils_1.NameType.Interface);
            // Build the response header
            const headersInterface = getResponseHeaderInterfaceDefinition(schemaResponse, baseResponseName);
            if (headersInterface) {
                hasHeaders = true;
            }
            const bodyType = getBodyTypeName(schemaResponse, importedModels);
            // Get the information to build the Response Interface
            const responseTypeName = operationHelpers_1.getResponseTypeName(operation, schemaResponse);
            const responseTypeDescription = operationLanguageMetadata.description;
            const responseProperties = getResponseInterfaceProperties(schemaResponse, bodyType, headersInterface === null || headersInterface === void 0 ? void 0 : headersInterface.name);
            const responseInterfaceDefinition = {
                name: responseTypeName,
                properties: responseProperties,
                isExported: true,
                extends: ["HttpResponse"]
            };
            // Only add a description if one was provided in the Swagger
            // otherwise skip to avoid having empty TSDoc lines
            if (responseTypeDescription) {
                responseInterfaceDefinition.docs = [
                    { description: responseTypeDescription }
                ];
            }
            // Add the response interface to the responses file
            responsesFile.addInterface(responseInterfaceDefinition);
        }
    }
    responsesFile.addImportDeclarations([
        {
            namedImports: ["HttpResponse"],
            moduleSpecifier: "@azure-rest/core-client"
        }
    ]);
    if (hasHeaders) {
        responsesFile.addImportDeclaration({
            namedImports: ["RawHttpHeaders"],
            moduleSpecifier: "@azure/core-rest-pipeline"
        });
    }
    responsesFile.addImportDeclarations([
        {
            namedImports: [...importedModels],
            moduleSpecifier: "./models"
        }
    ]);
}
exports.generateResponseInterfaces = generateResponseInterfaces;
/**
 * Gets the properties that need to be part of the response interface
 */
function getResponseInterfaceProperties(response, bodyTypeName, headersInterfaceName) {
    const statusCode = operationHelpers_1.getStatusCode(response);
    const responseProperties = [
        { name: "status", type: statusCode === `"default"` ? `"500"` : statusCode }
    ];
    if (bodyTypeName) {
        responseProperties.push({
            name: "body",
            type: bodyTypeName
        });
    }
    if (headersInterfaceName) {
        responseProperties.push({
            name: "headers",
            type: `RawHttpHeaders & ${headersInterfaceName}`
        });
    }
    return responseProperties;
}
/**
 * Body types are defined in the models file, this function checks if the current
 * response's body has a reference to a model or if it is a primitive, and returns the Typescript type
 * to generate
 * @param response - response to get the body type from
 * @param importedModels - track models to import
 */
function getBodyTypeName(response, importedModels) {
    return schemaHelpers_1.getElementType(response.schema, importedModels);
}
function getResponseHeaderInterfaceDefinition(response, baseName) {
    var _a, _b, _c;
    // Check if there are any required headers
    const hasDefinedHeaders = Boolean((_a = response.protocol.http) === null || _a === void 0 ? void 0 : _a.headers) &&
        Boolean((_b = response.protocol.http) === null || _b === void 0 ? void 0 : _b.headers.length);
    if (hasDefinedHeaders) {
        const headersInterfaceName = `${baseName}Headers`;
        return {
            kind: ts_morph_1.StructureKind.Interface,
            isExported: true,
            name: headersInterfaceName,
            properties: (_c = response.protocol.http) === null || _c === void 0 ? void 0 : _c.headers.map((h) => {
                const description = languageHelpers_1.getLanguageMetadata(h.language).description;
                return Object.assign(Object.assign({ name: `"${h.header.toLowerCase()}"` }, (description && { docs: [{ description }] })), { type: "string", hasQuestionToken: true });
            })
        };
    }
    return undefined;
}
// Gets a list of all the available operations requests in the specification
function getAllOperationRequests(model) {
    let operations = [];
    model.operationGroups.forEach(og => og.operations
        .filter(o => o.requests && o.requests.length)
        .forEach(o => {
        operations.push(o);
    }));
    return operations;
}
// Since REST clients don't throw on non-success status codes we treat responses and exceptions the same
function mergeResponsesAndExceptions(operation) {
    const responses = [];
    if (operation.responses) {
        responses.push(...operation.responses);
    }
    if (operation.exceptions) {
        responses.push(...operation.exceptions);
    }
    return responses;
}
//# sourceMappingURL=generateResponseTypes.js.map