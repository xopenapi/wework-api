"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePathFirstClient = void 0;
const codemodel_1 = require("@autorest/codemodel");
const operationHelpers_1 = require("./operationHelpers");
const ts_morph_1 = require("ts-morph");
const autorestSession_1 = require("../autorestSession");
const urlTransforms_1 = require("../transforms/urlTransforms");
const nameUtils_1 = require("../utils/nameUtils");
const schemaHelpers_1 = require("./schemaHelpers");
const languageHelpers_1 = require("../utils/languageHelpers");
function generatePathFirstClient(model, project) {
    var _a, _b, _c, _d;
    const name = nameUtils_1.normalizeName(languageHelpers_1.getLanguageMetadata(model.language).name, nameUtils_1.NameType.File);
    const clientFile = project.createSourceFile(`src/${name}.ts`, undefined, {
        overwrite: true
    });
    // Get all paths
    const importedParameters = new Set();
    const importedResponses = new Set();
    const pathDictionary = {};
    for (const operationGroup of model.operationGroups) {
        for (const operation of operationGroup.operations) {
            const operationName = languageHelpers_1.getLanguageMetadata(operation.language).name;
            const operationDescription = languageHelpers_1.getLanguageMetadata(operation.language)
                .description;
            const pathParameters = ((_a = operation.parameters) === null || _a === void 0 ? void 0 : _a.filter(p => { var _a; return ((_a = p.protocol.http) === null || _a === void 0 ? void 0 : _a.in) === codemodel_1.ParameterLocation.Path; }).map(p => {
                const languageMetadata = languageHelpers_1.getLanguageMetadata(p.language);
                return {
                    name: languageMetadata.serializedName || languageMetadata.name,
                    description: languageMetadata.description
                };
            })) || [];
            for (const request of operation.requests || []) {
                const path = ((_b = request.protocol.http) === null || _b === void 0 ? void 0 : _b.path) || "";
                const method = (_c = request.protocol.http) === null || _c === void 0 ? void 0 : _c.method;
                if (path && method) {
                    if (!pathDictionary[path]) {
                        pathDictionary[path] = {
                            pathParameters,
                            methods: {},
                            name: operationName
                        };
                    }
                    const hasOptionalOptions = !((_d = request.signatureParameters) === null || _d === void 0 ? void 0 : _d.some(p => p.required));
                    const newMethod = {
                        description: operationDescription,
                        optionsName: getOperationOptionsType(operation, importedParameters),
                        hasOptionalOptions,
                        returnType: `Promise<${getOperationReturnType(operation, importedResponses)}>`
                    };
                    if (pathDictionary[path].methods[`${method}`]) {
                        pathDictionary[path].methods[`${method}`].push(newMethod);
                    }
                    else {
                        pathDictionary[path].methods[`${method}`] = [newMethod];
                    }
                }
            }
        }
    }
    clientFile.addInterface({
        name: "Routes",
        isExported: true,
        callSignatures: getPathFirstRoutesInterfaceDefinition(pathDictionary, clientFile)
    });
    const clientName = languageHelpers_1.getLanguageMetadata(model.language).name;
    const uriParameter = getClientUriParameter();
    const { addCredentials, credentialKeyHeaderName } = autorestSession_1.getAutorestOptions();
    const credentialTypes = addCredentials ? ["TokenCredential"] : [];
    if (credentialKeyHeaderName) {
        credentialTypes.push("KeyCredential");
    }
    const commonClientParams = [
        ...(uriParameter ? [{ name: uriParameter, type: "string" }] : []),
        ...(addCredentials === false
            ? []
            : [{ name: "credentials", type: credentialTypes.join(" | ") }])
    ];
    const clientIterfaceName = `${clientName}RestClient`;
    // const factoryTypeName = `${clientName}Factory`;
    clientFile.addTypeAlias({
        isExported: true,
        name: clientIterfaceName,
        type: ts_morph_1.Writers.intersectionType("Client", ts_morph_1.Writers.objectType({ properties: [{ name: "path", type: "Routes" }] }))
    });
    clientFile.addFunction({
        isExported: true,
        name: clientName,
        parameters: [
            ...commonClientParams,
            { name: "options", type: "ClientOptions = {}" }
        ],
        returnType: clientIterfaceName,
        isDefaultExport: true,
        statements: getClientFactoryBody(clientIterfaceName)
    });
    if (importedParameters.size) {
        clientFile.addImportDeclaration({
            namedImports: [...importedParameters],
            moduleSpecifier: "./parameters"
        });
    }
    if (importedResponses.size) {
        clientFile.addImportDeclaration({
            namedImports: [...importedResponses],
            moduleSpecifier: "./responses"
        });
    }
    clientFile.addImportDeclarations([
        {
            namedImports: ["getClient", "ClientOptions", "Client"],
            moduleSpecifier: "@azure-rest/core-client"
        }
    ]);
    clientFile.addImportDeclarations([
        {
            namedImports: credentialTypes,
            moduleSpecifier: "@azure/core-auth"
        }
    ]);
}
exports.generatePathFirstClient = generatePathFirstClient;
function getOperationOptionsType(operation, importedParameters = new Set()) {
    const paramsName = `${languageHelpers_1.getLanguageMetadata(operation.language).name}Parameters`;
    importedParameters.add(paramsName);
    return paramsName;
}
function getClientFactoryBody(clientTypeName) {
    const { model } = autorestSession_1.getSession();
    const { endpoint, parameterName } = urlTransforms_1.transformBaseUrl(model);
    let baseUrl;
    if (parameterName) {
        const parsedEndpoint = endpoint === null || endpoint === void 0 ? void 0 : endpoint.replace(`{${parameterName}}`, `\${${parameterName}}`);
        baseUrl = `options.baseUrl ?? \`${parsedEndpoint}\``;
    }
    else {
        baseUrl = `options.baseUrl ?? "${endpoint}"`;
    }
    const apiVersion = getApiVersion();
    let apiVersionStatement = "";
    if (apiVersion) {
        apiVersionStatement = `options.apiVersion = options.apiVersion ?? "${apiVersion}"`;
    }
    const baseUrlStatement = {
        kind: ts_morph_1.StructureKind.VariableStatement,
        declarationKind: ts_morph_1.VariableDeclarationKind.Const,
        declarations: [{ name: "baseUrl", initializer: baseUrl }]
    };
    const { credentialScopes, credentialKeyHeaderName } = autorestSession_1.getAutorestOptions();
    const scopesString = credentialScopes && credentialScopes.length
        ? credentialScopes.map(cs => `"${cs}"`).join(", ")
        : "";
    const scopes = scopesString ? `scopes: [${scopesString}],` : "";
    const apiKeyHeaderName = credentialKeyHeaderName
        ? `apiKeyHeaderName: "${credentialKeyHeaderName}",`
        : "";
    const credentials = scopes || apiKeyHeaderName
        ? `options = {
      ...options,
      credentials: {
        ${scopes}
        ${apiKeyHeaderName}
      }
    }`
        : "";
    const getClient = `return getClient(
      baseUrl,
      ${credentials ? "credentials," : ""}
      options
    ) as ${clientTypeName};`;
    return [baseUrlStatement, apiVersionStatement, credentials, getClient];
}
function getApiVersion() {
    const { model } = autorestSession_1.getSession();
    if (!model.globalParameters || !model.globalParameters.length) {
        return undefined;
    }
    const apiVersionParam = model.globalParameters
        .filter(gp => {
        var _a;
        return gp.implementation === codemodel_1.ImplementationLocation.Client &&
            ((_a = gp.protocol.http) === null || _a === void 0 ? void 0 : _a.in) === codemodel_1.ParameterLocation.Query;
    })
        .find(param => languageHelpers_1.getLanguageMetadata(param.language).serializedName === "api-version");
    if (apiVersionParam && schemaHelpers_1.isConstantSchema(apiVersionParam.schema)) {
        return apiVersionParam.schema.value.value.toString();
    }
    return undefined;
}
function getOperationReturnType(operation, importedResponses = new Set()) {
    let returnType = "HttpResponse";
    if (operation.responses && operation.responses.length) {
        const responses = [...operation.responses, ...(operation.exceptions || [])];
        const responseTypes = responses
            .filter(r => { var _a, _b; return ((_a = r.protocol.http) === null || _a === void 0 ? void 0 : _a.statusCodes) && ((_b = r.protocol.http) === null || _b === void 0 ? void 0 : _b.statusCodes.length); })
            .map(r => {
            const responseName = operationHelpers_1.getResponseTypeName(operation, r);
            importedResponses.add(responseName);
            return responseName;
        });
        if (responseTypes.length) {
            returnType = responseTypes.join(" | ");
        }
    }
    return returnType;
}
function getPathFirstRoutesInterfaceDefinition(paths, sourcefile) {
    const signatures = [];
    for (const key of Object.keys(paths)) {
        generatePathFirstRouteMethodsDefinition(paths[key].name, paths[key].methods, sourcefile);
        const pathParams = paths[key].pathParameters;
        signatures.push({
            docs: [
                `Resource for '${key
                    .replace(/}/g, "\\}")
                    .replace(/{/g, "\\{")}' has methods for the following verbs: ${Object.keys(paths[key].methods).join(", ")}`
            ],
            parameters: [
                { name: "path", type: `"${key}"` },
                ...pathParams.map(p => {
                    return { name: p.name, type: "string", description: p.description };
                })
            ],
            returnType: paths[key].name,
            kind: ts_morph_1.StructureKind.CallSignature
        });
    }
    return signatures;
}
function getClientUriParameter() {
    const { model } = autorestSession_1.getSession();
    const { parameterName } = urlTransforms_1.transformBaseUrl(model);
    return parameterName;
}
function generatePathFirstRouteMethodsDefinition(operationName, methods, file) {
    const methodDefinitions = [];
    for (const key of Object.keys(methods)) {
        const method = methods[key];
        const description = methods[key][0].description;
        let areAllOptional = !method.some(m => !m.hasOptionalOptions);
        methodDefinitions.push(Object.assign(Object.assign({ name: key }, (description && { docs: [{ description }] })), { parameters: [
                {
                    name: "options",
                    hasQuestionToken: areAllOptional,
                    type: method.map(m => m.optionsName).join(" | ")
                }
            ], returnType: method.map(m => m.returnType).join(" | ") }));
    }
    file.addInterface({
        methods: methodDefinitions,
        name: operationName,
        isExported: true
    });
}
//# sourceMappingURL=generateClient.js.map