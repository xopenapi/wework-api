"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateParameterInterfaces = void 0;
const ts_morph_1 = require("ts-morph");
const languageHelpers_1 = require("../utils/languageHelpers");
const nameUtils_1 = require("../utils/nameUtils");
const getPropertySignature_1 = require("./getPropertySignature");
/**
 * Generates the interfaces describing each operation parameters
 */
function generateParameterInterfaces(model, project) {
    const parametersFile = project.createSourceFile(`src/parameters.ts`, undefined, {
        overwrite: true
    });
    // Tracks the models we need to import
    const importedModels = new Set();
    // Tracks the generated parameter types
    const operations = getAllOperations(model);
    for (const operation of operations) {
        const internalReferences = new Set();
        const operationName = nameUtils_1.normalizeName(languageHelpers_1.getLanguageMetadata(operation.language).name, nameUtils_1.NameType.Interface);
        const parameterInterfaceName = `${operationName}Parameters`;
        const parameters = getOperationParameters(operation);
        const queryParameterDefinitions = buildQueryParameterDefinition(operationName, parameters, importedModels, internalReferences);
        const bodyParameterDefinition = buildBodyParametersDefinition(operationName, parameters, importedModels, internalReferences);
        // Add interfaces for body and query parameters
        parametersFile.addInterfaces([
            ...(bodyParameterDefinition ? [bodyParameterDefinition] : []),
            ...(queryParameterDefinitions !== null && queryParameterDefinitions !== void 0 ? queryParameterDefinitions : [])
        ]);
        // Add Operation parameters type alias which is composed of the types we generated above
        // plus the common type RequestParameters
        parametersFile.addTypeAlias({
            name: parameterInterfaceName,
            isExported: true,
            type: [...internalReferences, "RequestParameters"].join(" & ")
        });
    }
    parametersFile.addImportDeclarations([
        {
            namedImports: ["RequestParameters"],
            moduleSpecifier: "@azure-rest/core-client"
        }
    ]);
    parametersFile.addImportDeclarations([
        {
            namedImports: [...importedModels],
            moduleSpecifier: "./models"
        }
    ]);
}
exports.generateParameterInterfaces = generateParameterInterfaces;
/**
 * Gets the interface definition for an operation bodyParameters
 */
function buildBodyParametersDefinition(operationName, parameters, importedModels, internalReferences) {
    const bodyParameters = parameters.filter(p => { var _a; return ((_a = p.protocol.http) === null || _a === void 0 ? void 0 : _a.in) === "body"; });
    if (!bodyParameters.length) {
        return undefined;
    }
    const bodyParameterInterfaceName = `${operationName}BodyParam`;
    // There is only one body parameter can't be more than one so we can safely take the first
    const bodySignature = getPropertySignature_1.getPropertySignature(bodyParameters[0], importedModels);
    internalReferences.add(bodyParameterInterfaceName);
    return {
        isExported: true,
        kind: ts_morph_1.StructureKind.Interface,
        name: bodyParameterInterfaceName,
        properties: [
            {
                name: "body",
                type: bodySignature.type,
                hasQuestionToken: bodySignature.hasQuestionToken
            }
        ]
    };
}
/**
 * Gets the interface definition for an operation queryParameters
 */
function buildQueryParameterDefinition(operationName, parameters, importedModels, internalReferences) {
    const queryParameters = parameters.filter(p => { var _a; return ((_a = p.protocol.http) === null || _a === void 0 ? void 0 : _a.in) === "query"; });
    if (!queryParameters.length) {
        return undefined;
    }
    const queryParameterInterfaceName = `${operationName}QueryParam`;
    const queryParameterPropertiesName = `${operationName}QueryParamProperties`;
    // Get the property signature for each query parameter
    const propertiesDefinition = queryParameters.map(qp => getPropertySignature_1.getPropertySignature(qp, importedModels));
    const hasRequiredParameters = propertiesDefinition.some(p => !p.hasQuestionToken);
    const propertiesInterface = {
        kind: ts_morph_1.StructureKind.Interface,
        isExported: true,
        name: queryParameterPropertiesName,
        properties: propertiesDefinition
    };
    const parameterInterface = {
        kind: ts_morph_1.StructureKind.Interface,
        isExported: true,
        name: queryParameterInterfaceName,
        properties: [
            {
                name: "queryParameters",
                type: queryParameterPropertiesName,
                // Mark as optional if there are no required parameters
                hasQuestionToken: !hasRequiredParameters
            }
        ]
    };
    // Mark the queryParameter interface for importing
    internalReferences.add(queryParameterInterfaceName);
    return [propertiesInterface, parameterInterface];
}
/**
 * Flattens all operations from operationGroups
 */
function getAllOperations(model) {
    const operations = [];
    for (const operationGroup of model.operationGroups) {
        operations.push(...operationGroup.operations);
    }
    return operations;
}
function getOperationParameters(operation) {
    var _a, _b;
    const signatureParameters = (_a = operation.signatureParameters) !== null && _a !== void 0 ? _a : [];
    // Extract parameters from the operation request
    const request = operation.requests ? operation.requests[0] : undefined;
    const requestParameters = (_b = request === null || request === void 0 ? void 0 : request.signatureParameters) !== null && _b !== void 0 ? _b : [];
    return [...signatureParameters, ...requestParameters];
}
//# sourceMappingURL=generateParameterTypes.js.map